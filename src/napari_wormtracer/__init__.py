import functools
from collections import defaultdict
from pathlib import Path
from typing import TYPE_CHECKING

import numpy as np
from napari.utils.notifications import show_error, show_info, show_warning
from qtpy.QtCore import Qt
from qtpy.QtWidgets import QFileDialog, QGridLayout, QPushButton, QWidget
from scipy import interpolate

if TYPE_CHECKING:
    import napari

__all__ = ["WormTracerUI"]


class WormTracerUI(QWidget):
    def __init__(self, viewer: "napari.viewer.Viewer", parent=None):
        super().__init__(parent)

        show_info("WormTracer GUI was loaded")

        self._viewer: napari.Viewer = viewer
        # QPushButton (name, callback)
        btns = [
            ("Load Image", self._load_image),
            ("Load Centerline", self._load_centerline),
            ("Prev (-1)", functools.partial(self._move_frame, step=-1)),
            ("Next (+1)", functools.partial(self._move_frame, step=1)),
            ("Clear", self._reset_centerline),
            ("Reload", self._reload_centerline),
            ("Flip", self._flip),
            ("Register", self._register),
            ("Undo", self._undo),
            ("Save All", self.save_all),
        ]
        ncol = 2
        layout = QGridLayout(self)
        layout.setSpacing(0)
        for i, (name, callback) in enumerate(btns):
            btn = QPushButton(self)
            btn.setText(name)
            btn.setMinimumHeight(60)
            btn.setMinimumWidth(108)
            btn.clicked.connect(callback)
            row_idx = i // ncol
            col_idx = i % ncol
            layout.addWidget(btn, row_idx, col_idx, Qt.AlignmentFlag.AlignCenter)

        self.centerlines = None
        self.setLayout(layout)

        self.is_flip = None
        # Memory the unmodified line. for redo
        self.history = defaultdict(list)
        # src_path
        self.src_path = None

        # layers
        self.shapes_layer = None
        self.nose_tip_layer = None

    def _move_frame(self, step: int):
        z_idx = self._viewer.dims.current_step[0]
        # reset current index
        self._reset_centerline()
        next_step = max(z_idx + step, 0)
        if self.centerlines is not None:
            T = self.centerlines.shape[0]
            next_step = min(next_step, T - 1)
        self._viewer.dims.set_current_step(0, next_step)

    def save_all(self):
        if self.centerlines is None or self.src_path is None:
            return
        assert self.is_flip is not None, ""

        try:
            x_src, y_src = self.src_path
            x_dst = x_src.with_stem(x_src.stem + "_modified")
            y_dst = y_src.with_stem(y_src.stem + "_modified")

            # Z, Y, X
            x = self.centerlines[:, :, 2]
            y = self.centerlines[:, :, 1]
            # Flip the output
            mask = self.is_flip == 1
            x[mask, :] = x[mask, ::-1]
            y[mask, :] = y[mask, ::-1]
            np.savetxt(x_dst, x, delimiter=",")
            np.savetxt(y_dst, y, delimiter=",")
            show_info("Modified centerline was saved.")
        except KeyError:
            return

    def _load_centerline(
        self,
    ):
        x_path, _ = QFileDialog.getOpenFileName(
            self,
            caption="Select .csv file generated by WormTracer (_x.csv)",
            filter="Csv Files (*.csv);;All Files (*.*)",
        )
        folder = Path(x_path).parent
        name = Path(x_path).name
        if "_x" in name:
            x_name = name
            y_name = name.replace("_x", "_y", count=1)
        elif "_y" in name:
            y_name = name
            x_name = name.replace("_y", "_x", count=1)
        else:
            if self.centerlines is None:
                show_error(
                    f"Select file did not contains proper suffixes (_x or _y): {name}"
                )
            return

        self.src_path = (folder.joinpath(x_name), folder.joinpath(y_name))
        self._reload_centerline()
        self._viewer.dims.set_current_step(0, 0)

    def _reload_centerline(self):
        if self.src_path is None:
            return

        if self.shapes_layer is not None:
            self._viewer.layers.remove(self.shapes_layer)

        if self.nose_tip_layer is not None:
            self._viewer.layers.remove(self.nose_tip_layer)

        x_src, y_src = self.src_path
        # load x and y
        x = np.loadtxt(x_src, delimiter=",")
        y = np.loadtxt(y_src, delimiter=",")

        T, plot_n = x.shape
        z = np.repeat(np.arange(T), plot_n).reshape(T, plot_n)
        self.centerlines = np.stack([z, y, x], axis=-1)  # (1500, 100, 3)
        self.shapes_layer = self._viewer.add_shapes(
            data=[skel for skel in self.centerlines],
            ndim=3,
            shape_type="path",  # 'path' means polyline in napari
            name="centerline",
            # This parameter is crucial: it tells napari how to group the vertices
            # into separate shapes (one shape per time point in this case)
            face_color="transparent",
            edge_color="yellow",
            edge_width=2,
        )
        self.shapes_layer.editable = True
        # (T, 1, 3) => (T, 4, 3)
        # [4, 3] => [1, 4, 3]
        self.nose_tip_layer = self._viewer.add_points(
            data=[skel[0] for skel in self.centerlines],
            ndim=3,
            name="nose",
            # This parameter is crucial: it tells napari how to group the vertices
            # into separate shapes (one shape per time point in this case)
            face_color="transparent",
            border_color="red",
            size=5,
            border_width=0.15,
        )
        self.nose_tip_layer.editable = False
        # memory whether current centerline was flip or not
        self.is_flip = np.repeat(0, T).astype("u1")

    def _load_image(self):
        file_path, _ = QFileDialog.getOpenFileName(
            self,
            caption="Select an Image File",
            filter="Image Files (*.png *.tif *.tiff *.jpg);;All Files (*.*)",
        )
        if not file_path:
            show_warning("Selection aborted!")
            return

        im_layer = self._viewer.open(file_path, stack=True)
        current_index = self._viewer.layers.index(im_layer[0])
        # Move the image to the button
        self._viewer.layers.move(current_index, 0)
        self._viewer.dims.set_current_step(0, 0)

        # layer = self._viewer.add_image(image_data, name=path.split("/")[-1])

    def _register(self):
        if self.centerlines is None:
            return
        assert self.is_flip is not None, "Some problem occurs"
        assert self.shapes_layer is not None, ""
        assert self.nose_tip_layer is not None, ""
        z_idx = self._viewer.dims.current_step[0]

        data = self.shapes_layer.data
        # Get all shapes associated to current indices
        current_data = [
            (i, d) for (i, d) in enumerate(data) if d[0, 0] == z_idx and d.shape[0] > 1
        ]

        if not current_data:
            return

        if len(current_data) > 1:
            #  Drop the previous shape
            current_data = [(i, d) for (i, d) in current_data if i != z_idx]

        _, new_shape = min(current_data, key=lambda x: x[0])
        n_pts = new_shape.shape[0]
        arc_length = np.zeros(n_pts)

        square_diff = (new_shape[1:] - new_shape[:-1]) ** 2
        arc_length[1:] = np.sqrt(square_diff.sum(axis=1))
        arc_length = np.cumsum(arc_length)
        # normalized to [0.0, 1.0]
        arc_length /= arc_length.max()
        cs = interpolate.CubicSpline(
            arc_length,
            new_shape,
        )
        plot_n = self.centerlines.shape[1]
        interpolated_data = cs(np.linspace(0, 1.0, plot_n))
        interpolated_data[:, 0] = z_idx

        # Memory the previous centerline for undo.
        self.history[z_idx].append(self.centerlines[z_idx].copy())
        # Assign the interpolated data to centerline
        self.centerlines[z_idx] = interpolated_data
        # reset flip
        self.is_flip[z_idx] = 0
        # Update the centerline using reset_centerline
        self._reset_centerline()

    def _flip(self):
        if self.centerlines is None:
            return
        assert self.is_flip is not None, "Some problem occurs"
        z_idx = self._viewer.dims.current_step[0]
        self.is_flip[z_idx] = self.is_flip[z_idx] ^ 1
        self._reset_centerline()

    def _reset_centerline(self):
        if self.centerlines is None:
            return
        assert self.is_flip is not None, ""
        assert self.shapes_layer is not None, ""
        assert self.nose_tip_layer is not None, ""

        data = self.shapes_layer.data
        T = self.centerlines.shape[0]
        if len(data) > T:
            # Remove additional shape
            # Get all z stack indices
            indices = np.array([d[0, 0] for d in data])
            # Get first occurence index.
            z_values, indices = np.unique(indices, return_index=True)
            # sort by z_values
            sorted_indices = indices[np.argsort(z_values)]
            data = [data[i] for i in sorted_indices]

        z_idx = self._viewer.dims.current_step[0]
        skel = self.centerlines[z_idx]

        if self.is_flip[z_idx]:
            skel = skel[::-1, :]

        data[z_idx] = skel
        # we have to assign the data to update the drawing
        self.shapes_layer.data = data

        data = self.nose_tip_layer.data
        data[z_idx] = skel[0]
        # we have to assign the data to update the drawing
        self.nose_tip_layer.data = data

    def _undo(self):
        if self.centerlines is None:
            return

        z_idx = self._viewer.dims.current_step[0]
        try:
            prev_skel = self.history[z_idx].pop()
            self.centerlines[z_idx] = prev_skel
        except IndexError:
            # No history found
            pass
        finally:
            self._reset_centerline()
